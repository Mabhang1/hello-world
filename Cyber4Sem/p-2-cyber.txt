Aim:Write a program to implement the (i) Affine Cipher (ii) Rail Fence Technique (iii) 
Simple Columnar Technique (iv) Vermin Cipher (v) Hill Cipher to perform 
encryption and decryption. 

Theory:
(i) Affine Cipher:
The Affine Cipher is a type of substitution cipher where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a simple mathematical function, and converted back to a letter. It uses a pair of numbers (a and b) as the key. The encryption function for a letter x is (ax + b) mod m, where m is the size of the alphabet.
Example:
Let's encrypt the message "HELLO" using the key (a = 5, b = 8) in a standard English alphabet with 26 letters.
H -> 7, E -> 4, L -> 11, L -> 11, O -> 14
Encrypting: (75 + 8) mod 26 = 45 mod 26 = 19 -> T, (45 + 8) mod 26 = 28 mod 26 = 2 -> C, (11*5 + 8) mod 26 = 63 mod 26 = 11 -> L, and so on.
So, "HELLO" would be encrypted as "TCXXA".

(ii) Rail Fence Technique:
The Rail Fence Technique is a transposition cipher where the plaintext is written diagonally and read off horizontally in a zigzag pattern. The number of "rails" or lines used is the key for this cipher.
Example:
Encrypting the message "HELLO" with 3 rails:

H . . . O . . . // First rail
. E . L . . . // Second rail
. . L . . . . . // Third rail

Reading off horizontally: "HOELLL"

(iii) Simple Columnar Technique:
This is a transposition cipher where the plaintext is written out in rows of a fixed length, and then read out again column by column according to a permutation of the columns.
Example:
Encrypting the message "HELLO" with a keyword "KEY" (where alphabetical order of keyword letters determines column order):

K E Y // Columns determined by the keyword
---------
H E L // Rows of plaintext
L O . // Filled with a null character for uneven length

Reading off column by column: "HLELO".
(iv) Vermin Cipher:
The Vermin Cipher is a substitution cipher similar to the Caesar Cipher but with a varying shift that depends on the position of the letter within the plaintext.
Example:
Encrypting the message "HELLO" using a starting shift of 3:
H -> (3+1) mod 26 = 4 -> E
E -> (3+2) mod 26 = 5 -> F
L -> (3+3) mod 26 = 6 -> G
L -> (3+4) mod 26 = 7 -> H
O -> (3+5) mod 26 = 8 -> I
So, "HELLO" would be encrypted as "EFHIG".

(v) Hill Cipher:
The Hill Cipher is a polygraphic substitution cipher based on linear algebra. It encrypts blocks of plaintext letters at a time and uses matrix multiplication. The key for this cipher is a matrix.
Example:
Encrypting the message "HELLO" with a 2x2 key matrix:

Key matrix: [[1, 2], [3, 1]]
Plaintext matrix: [H, E; L, L; O, null]

Multiplying the key matrix with the plaintext matrix:

[[1, 2], [3, 1]] * [[7, 4], [11, 11]] = [[7+22, 4+8], [33+11, 11+3]] = [[29, 12], [44, 14]]

Taking mod 26 for each element:

[[29 mod 26, 12 mod 26], [44 mod 26, 14 mod 26]] = [[3, 12], [18, 14]]

Converting back to letters: "3" -> C, "12" -> L, "18" -> S, "14" -> O
So, "HELLO" would be encrypted as "CLOS".

Source Code:
import java.util.Scanner;

public class CiphersDemo {
    
    public static void main(String[] args) {
        System.out.println("4701-Abhang Mane");
        System.out.println("****Ciphers****");
        
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter plaintext: ");
        String plaintext = scanner.nextLine().toUpperCase();
        
        // Affine Cipher
        int a = 5;
        int b = 8;
        String affineCipher = affineEncrypt(plaintext, a, b);
        System.out.println("Affine Cipher: " + affineCipher);
        
        // Rail Fence Cipher
        int rails = 3;
        String railFenceCipher = railFenceEncrypt(plaintext, rails);
        System.out.println("Rail Fence Cipher: " + railFenceCipher);
        
        // Simple Columnar Cipher
        String key = "231";
        String simpleColumnarCipher = simpleColumnarEncrypt(plaintext, key);
        System.out.println("Simple Columnar Cipher: " + simpleColumnarCipher);
        
        // Vermin Cipher
        int shift = 3;
        String verminCipher = verminEncrypt(plaintext, shift);
        System.out.println("Vermin Cipher: " + verminCipher);
        
        // Hill Cipher
        int[][] keyMatrix = {{6, 24, 1}, {13, 16, 10}, {20, 17, 15}};
        String hillCipher = hillEncrypt(plaintext, keyMatrix);
        System.out.println("Hill Cipher: " + hillCipher);
        
        scanner.close();
    }
    
    // Affine Cipher
    public static String affineEncrypt(String text, int a, int b) {
        StringBuilder result = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) {
                int x = (int) ch - 'A';
                x = (a * x + b) % 26;
                result.append((char) (x + 'A'));
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }
    
    // Rail Fence Cipher
    public static String railFenceEncrypt(String text, int rails) {
        StringBuilder result = new StringBuilder();
        char[][] grid = new char[rails][text.length()];
        int row = 0;
        boolean down = false;
        for (int i = 0; i < text.length(); i++) {
            grid[row][i] = text.charAt(i);
            if (row == 0 || row == rails - 1) {
                down = !down;
            }
            row += down ? 1 : -1;
        }
        for (int i = 0; i < rails; i++) {
            for (int j = 0; j < text.length(); j++) {
                if (grid[i][j] != 0) {
                    result.append(grid[i][j]);
                }
            }
        }
        return result.toString();
    }
    
    // Simple Columnar Cipher
    public static String simpleColumnarEncrypt(String text, String key) {
        int[] indexes = new int[key.length()];
        for (int i = 0; i < key.length(); i++) {
            indexes[i] = key.indexOf(i + '1');
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < key.length(); i++) {
            for (int j = indexes[i]; j < text.length(); j += key.length()) {
                result.append(text.charAt(j));
            }
        }
        return result.toString();
    }
    
    // Vermin Cipher
    public static String verminEncrypt(String text, int shift) {
        StringBuilder result = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) {
                int x = (int) ch + shift;
                if (Character.isUpperCase(ch) && x > 'Z') {
                    x -= 26;
                } else if (Character.isLowerCase(ch) && x > 'z') {
                    x -= 26;
                }
                result.append((char) x);
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }
    
    // Hill Cipher
    public static String hillEncrypt(String text, int[][] key) {
        StringBuilder result = new StringBuilder();
        int n = key.length;
        int[] vec = new int[n];
        for (int i = 0; i < text.length(); i += n) {
            for (int j = 0; j < n; j++) {
                vec[j] = (int) text.charAt(i + j) - 'A';
            }
            for (int j = 0; j < n; j++) {
                int sum = 0;
                for (int k = 0; k < n; k++) {
                    sum += key[j][k] * vec[k];
                }
                result.append((char) ((sum % 26) + 'A'));
            }
        }
        return result.toString();
    }
}


















Output:


Conclusion: Hence All the ciphers were implemented successfully encrypting and decrypting plaintext.































